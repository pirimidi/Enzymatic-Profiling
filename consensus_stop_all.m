%--------------------------------------------------------------------------
% Author: Mirko Palla, PhD.
% Date: March 23, 2017
%
% For: Single molecule DNA sequencing via aHL nanopore array at the Church
% Lab - Genetics Department, Harvard Medical School.
%
% Purpose: This program receives a set of MAT-files, one for each ('pol-bar') 
% experiment, containing all alignment parameters generated by 
% 'consensus_alignment.m'. Then, for each 'pol-bar', it iterates through 
% the experimental structures and generates normalized whisker plots 
% featuring consensus alignment accuracy (%) of all pores with distinct 
% barcode iterations (n = 1, 2, ..., n) for each 'pol-bar' case displaying 
% them on the same plot for comparison. NOTE: Use MATLAB R2017a to run this
% code, older version might trigger errors. 
%
% This software may be used, modified, and distributed freely, but this
% header may not be modified and must appear at the top of this file.
%--------------------------------------------------------------------------

function consensus_stop_all

%-------------------------------------------------------------------------%
%                                 STARTUP                                 %
%-------------------------------------------------------------------------%

% Start timer.
tic 

fprintf('\n');
disp('--> Consensus pol-bar stop start');
fprintf('\n');

% Set default number formatting.
format short;

% Turn off warnings during run.
warning('off', 'all');

% Define current working and data directory.
work_dir = pwd;

% Define barcode list.
barcodes = {'comp3', 'fv2', 'rep3'};

% Set up regular expressions for "lumping" "stuttery" regions.
expr = {'A+', 'C+', 'T+', 'G+'};
repl = {'A'; 'C'; 'T'; 'G'};

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%                          DIRECTORY NAVIGATION                           %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

disp('--> DIRECTORY NAVIGATION SECTION');

% Navigate to 'pol-bar' MAT-file directory.
fas_dir = strcat(work_dir, '/data/mat_files');
cd(fas_dir);

disp(['--> IN DIRECTORY: ' fas_dir]);

% Read in FAS files for predefined barcodes (comp3, fv2, rep3).
bar_seqs = fastaread('barcode_list.fas');

% Navigate to 'pol-bar' MAT-file directory.
data_dir = strcat(work_dir, '/data/mat_files/cons');
cd(data_dir);

disp(['--> IN DIRECTORY: ' data_dir]);

% Read in all 'experiment' folder names one-by-one.
list = dir('pol6*_cons*.mat');

% Figure counter.
counter = 1;

disp('--> NORMALIZED WHISKER PLOTTING SECTION');
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%                              WHISKER PLOTTING                           %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Generate 'experimental set' directory to hold the whisker plots.
cdir = 'consensus_stop_all';

% Define direcory to hold figures.
if ~exist(cdir, 'dir')
  mkdir(cdir);
end

% Iterate through all 'pol' folders.
 for e = 1:length(list) 

    % Iterate through all three barcodes.
    for bar = 1:length(barcodes)  

        % Define array container for fragment and grouping variable array.
        id = []; ge = [];
        
        % Definte sliding window alignment structure.
        pol_stop = struct;

        % Load nanopore data structure per experimental set (pol-bar).
        load(list(e).name);
        disp(['--> MAT-FILE LOADED: ' list(e).name]);
        ss = strsplit(list(e).name, '.');
    
        % Iterate through all 'experiment' folders for (pol-)bar.
        for exp = 1:length(cons_list(bar).experiment)

            % Only look at structures with elements (can be empty).
            if length(cons_list(bar).experiment(exp).s) > 1
                
                % Iterate through all experiments per (pol-)bar and plot desired field. 
                pb = cons_list(bar).experiment(exp).s;

                % Find maximum iteration number.
                max_iter = max(extractfield(pb, 'iteration'));

                % Iterate through all pores with full iteration number 'm'. 
                for m = 1:max_iter

                    % Initialize temporary fragment container.
                    fr = {}; index = []; frag = {}; frag_f = {}; fc = 1;

                    % Find iteration values.
                    index = extractfield(pb, 'iteration') >= m;

                    % Find alignment fragment character array for each such pore.
                    frag = extractfield(pb(index), 'alignment_fragments');
                        
                    for f = 1:length(frag)

                        % Update fragment container array.                                                 
                        frag_f = frag(f);

                        if ~isempty(frag_f{1})
                            fr{fc} = frag_f{1}{m};
                            fc = fc + 1;
                        end
                        
                    end

                    % Correct for single fragment.
                    if iscell(fr)

                        % Calculate consensus sequence and consensus identity.
                        if length(fr) == 1
                            cseq = regexprep(fr{1}, '-', ''); % lump;
                            
                            % Update multialignment-based fields.
                            ma = struct;
                            profile = [];
                            wgtmatrix = {};

                        elseif length(fr) == 2
                            [d_score, d_alignment, d_start] = swalign(fr{1}, fr{2});
                            [r, c] = size(d_alignment);
                                                        
                            for di = 1:c
                                if d_alignment(1+3*(di-1)) == '-'
                                    cseq(di) = d_alignment(3+3*(di-1));
                                else
                                    cseq(di) = d_alignment(1+3*(di-1));
                                end
                            end
                            
                            % Update multialignment-based fields.
                            ma = d_alignment;
                            profile = [];
                            wgtmatrix = {}; 

                        % Case for more than 3 iterations.
                        else

                            % Calculate consensus for iter = m.
                            ma = multialign(fr, 'ExistingGapAdjust', false, 'TerminalGapAdjust', true);
                            cseq = seqconsensus(ma, 'Alphabet', 'NT', 'Gaps', 'none');
                            [profile, symbols] = seqprofile(ma, 'Alphabet', 'NT', 'Counts', 'false', 'Gaps', 'none');
                            [wgtmatrix, handle] = seqlogo(ma, 'Displaylogo', 'false');

                        end
                    end

                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    % Calculate consensus identity to CORRECT template.
                    template = bar_seqs(bar).Sequence;
                    lumped_template = regexprep(template, expr, repl, 'ignorecase');
                    lumped_cseq = regexprep(cseq, expr, repl, 'ignorecase');
                    [c_score, c_alignment, c_start] = swalign(lumped_template, lumped_cseq);
                    
                    % Add consensus object to 'cons list'.
                    pol_stop(bar).experiment(exp).s(m).max_iter = max_iter;
                    pol_stop(bar).experiment(exp).s(m).alignment_fragments = fr;
                    pol_stop(bar).experiment(exp).s(m).template = template;
                    pol_stop(bar).experiment(exp).s(m).lumped_template = lumped_template;

                    pol_stop(bar).experiment(exp).s(m).multialign = ma;
                    pol_stop(bar).experiment(exp).s(m).consensus = cseq;
                    pol_stop(bar).experiment(exp).s(m).lumped_consensus = lumped_cseq;
                    pol_stop(bar).experiment(exp).s(m).profile = profile;
                    pol_stop(bar).experiment(exp).s(m).weight_matrix = wgtmatrix;

                    % Assign fields to consensus alignment object.
                    pol_stop(bar).experiment(exp).s(m).cons_score = c_score;
                    pol_stop(bar).experiment(exp).s(m).cons_alignment = c_alignment;
                    pol_stop(bar).experiment(exp).s(m).cons_alignment_length = length(c_alignment);
                    pol_stop(bar).experiment(exp).s(m).cons_start = c_start;
                    
                    % Force alignment/consensus length to be at least 10 bp.
                    if length(c_alignment) >=  10
                        
                        % Initialize match, mismatch and deletion counters.
                        mat_count = 0;
                        mis_count = 0;  
                        ins_count = 0;
                        del_count = 0;

                        % Initialize match, mismatch and deletion index arrays.
                        mat_index = [];
                        mis_index = [];
                        ins_index = [];
                        del_index = [];  

                        % Compute number of matches, mismatchs and deletions.
                        for k = 1:length(c_alignment)

                            % An insertion.
                            if strcmp(c_alignment(1+3*(k-1)), '-')

                                ins_count = ins_count + 1;
                                ins_index = [ins_index k];

                            % A deletion.
                            elseif strcmp(c_alignment(3+3*(k-1)), '-')

                                del_count = del_count + 1;
                                del_index = [del_index k];

                            % A match or mismatch.    
                            else

                                % Count number of matches.
                                if strcmp(c_alignment(1+3*(k-1)), c_alignment(3+3*(k-1)))

                                    mat_count = mat_count + 1;
                                    mat_index = [mat_index k];

                                % Count number of mismatchs.
                                elseif not(strcmp(c_alignment(1+3*(k-1)), c_alignment(3+3*(k-1))))

                                    mis_count = mis_count + 1;
                                    mis_index = [mis_index k];

                                end
                            end
                        end

                        % Calculate identity (%) of full alignment.
                        total = length(c_alignment(2, :));
                        match = length(find(c_alignment(2, :) == '|'));
                        identity = match/total*100;

                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                     
                        % Assign fields to consensus alignment object (> 10).
                        pol_stop(bar).experiment(exp).s(m).cons_match_count = mat_count;
                        pol_stop(bar).experiment(exp).s(m).cons_mismatch_count = mis_count;
                        pol_stop(bar).experiment(exp).s(m).cons_insertion_count = ins_count;
                        pol_stop(bar).experiment(exp).s(m).cons_deletion_count = del_count;

                        pol_stop(bar).experiment(exp).s(m).cons_match_index = mat_index;
                        pol_stop(bar).experiment(exp).s(m).cons_mismatch_index = mis_index;
                        pol_stop(bar).experiment(exp).s(m).cons_insertion_index = ins_index; 
                        pol_stop(bar).experiment(exp).s(m).cons_deletion_index = del_index;   

                        % Absolute index position in barcode.
                        if isempty(mat_index) 
                            pol_stop(bar).experiment(exp).s(m).abs_cons_match_index = mat_index;
                        else
                            pol_stop(bar).experiment(exp).s(m).abs_cons_match_index = mat_index + c_start(1);
                        end

                        if isempty(mis_index) 
                            pol_stop(bar).experiment(exp).s(m).abs_cons_mismatch_index = mis_index;
                        else
                            pol_stop(bar).experiment(exp).s(m).abs_cons_mismatch_index = mis_index + c_start(1);
                        end

                        if isempty(ins_index) 
                            pol_stop(bar).experiment(exp).s(m).abs_cons_insertion_index = ins_index;
                        else
                            pol_stop(bar).experiment(exp).s(m).abs_cons_insertion_index = ins_index + c_start(1);
                        end

                        if isempty(del_index) 
                            pol_stop(bar).experiment(exp).s(m).abs_cons_deletion_index = del_index;
                        else
                            pol_stop(bar).experiment(exp).s(m).abs_cons_deletion_index = del_index + c_start(1); 
                        end

                        pol_stop(bar).experiment(exp).s(m).cons_identity = identity;

                        % Update consensus alignment % and grouping variable array.
                        id = [id; identity]; ge = [ge; m];
                        
                    end                         
                end
            end
        end 
        
        id
        ge

        % Generate figure for each pol-bar combination.
        figure(counter);

        % Create dwell time (s) boxplot of all filtered events (exp).
        boxplot(id./100, ge, 'PlotStyle', 'compact', 'Symbol', 'b', 'Whisker', 0.2413);
        grid;
        title('consensus identity pol stop');
        xlabel('number of iterations');
        ylabel('consensus identity');
        ylim([0 1]);

        % Save plot.
        pp = strsplit(ss{1}, '_');
        fn = [pp{1}, '_', barcodes{bar}, '_stop_all'];
        savefig([fn, '.fig']);
        print('-dbmp', [fn, '.bmp']);

        % Update counter.
        counter = counter + 1;

        % Summary statistics organized by group.
        [mean, sem, numel, gname, std, var, minimum, maximum, range] = ...
         grpstats(id, ge, {'mean', 'sem', 'numel', 'gname', 'std', 'var', ...
                            'min', 'max', 'range'})

        disp(['--> PROCESSED DATA SET: ' fn]);  

        % Generate M-file containing all experimental statistics for each barcode.
        save([fn, '.mat'], 'pol_stop');

        % Write statistical results to file and append as needed.
        M = grpstats(id, ge, {'mean', 'sem', 'numel', 'gname', 'std', 'var', 'min', 'max', 'range'});
        dlmwrite([pp{1}, '_stats_out.txt'], M, 'delimiter', '\t');
          
    end 
end    
    
% Move all figures to 'plots' directory.
movefile('*.fig', cdir);
movefile('*.bmp', cdir);

% Close all open figures.
close all;        
    
% Navigate to working directory.
cd(work_dir);

fprintf('\n');
disp('--> Consensus pol-bar stop end');
fprintf('\n');

% End timer.
toc
%--------------------------------------------------------------------------
% Author: Mirko Palla, PhD.
% Date: Jult 24, 2017
%
% For: Single molecule DNA sequencing via aHL nanopore array at the Church
% Lab - Genetics Department, Harvard Medical School.
%
% Purpose: This program receives a MAT-file, containing all alignment 
% parameters generated by 'consensus_alignment_96.m'. Then, it iterates 
% through the experimental structures and collects all pore IDs, which are 
% categorized as a high-probability barcode hits (consensus alignment 
% accuracy (CAA) > 80%, 50 bp < alignment length < 500 bp), along with the 
% 20 kinetic parameters (KP) used in the PCA analysis. Next, it selects the
% ones with the highest CAA for each pore ID with multiple potential 
% barcode hits. Finally, ...
%
% Case 1:
% ..., given a specific barcode ID (with the maximum frequency count), it 
% caluclates the PCA based on the 20 KP associated with this list of pores.
%
% Case 2: 
% ..., it randomly samles N pores from the appropriate barcode set, and 
% PCA-maps back as before. This way, the maixum number of N can be
% determined for "good" mapping. 
%
% This can be mapped back to PCA Fig. 6 in the main text for RPol
% verification. NOTE: Use MATLAB R2017a to run this code, older 
% version might trigger errors.
%
% This software may be used, modified, and distributed freely, but this
% header may not be modified and must appear at the top of this file.
%--------------------------------------------------------------------------

function pca_mapback_pol_filter(x_min, x_max, y_min, type)

%-------------------------------------------------------------------------%
%                                 STARTUP                                 %
%-------------------------------------------------------------------------%

% Start timer.
tic 

fprintf('\n');
disp('--> PCA map back start');
fprintf('\n');

% Set default number formatting.
format short;

% Turn off warnings during run.
warning('off', 'all');

% Define current working and data directory.
work_dir = pwd;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%                          DIRECTORY NAVIGATION                           %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

disp('--> DIRECTORY NAVIGATION SECTION');

% Navigate to MAT-file directory.
mat_dir = strcat(work_dir, '\data\harvard\mat_files');
cd(mat_dir);

disp(['--> IN DIRECTORY: ' mat_dir]);

% Read in a TXT file for predefined 96 naive barcodes.
bar_seqs = fastaread('unique_barcodes_50%.txt');

% Read in all 'experiment' folder names one-by-one.
list = dir('pol6*_*merge*.mat');
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%                              SCATTER PLOTTING                           %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

disp('--> NORMALIZED SCATTER PLOTTING SECTION');

% Figure counter.
counter = 1;

% Create empty data matrix.
DATA = [];

% Generate 'experimental set' di rectory to hold the scatter plots.
cdir = 'pca_mapback';

% Define direcory to hold figures.
if ~exist(cdir, 'dir')
  mkdir(cdir);
end

% Iterate through all MAT-files (currently only one).
 for e = 1:length(list) 

    % Load nanopore data structure per experimental set.
    load(list(e).name);
    disp(['--> MAT-FILE LOADED: ' list(e).name]);
    ww = strsplit(list(e).name, '.');

    % Define array container for all data.
    UC = 0;
    ALL_CI = []; ALL_GE = []; ALL_BC = []; ALL_EX = []; 
       
    AKC = []; AKO = []; ADT = []; ATM = []; ATR = [];
    CKC = []; CKO = []; CDT = []; CTM = []; CTR = [];
    GKC = []; GKO = []; GDT = []; GTM = []; GTR = [];
    TKC = []; TKO = []; TDT = []; TTM = []; TTR = [];
        
    % Iterate through all 'experiment' folders, here we have 8.
    for exp = 1:length(merge_list(1).experiment)

        % Define array container for fixed 'experiment' and grouping 
        % variable array.
        CI = []; GE = []; BC = []; EX = [];
        ci = []; ge = {}; bc = []; ex = [];
        
        % Initialize conatiner arrays for the 20 kinetic properties for 
        % filtered cells.
        Akc = []; Ako = []; Adt = []; Atm = []; Atr = [];
        Ckc = []; Cko = []; Cdt = []; Ctm = []; Ctr = [];
        Gkc = []; Gko = []; Gdt = []; Gtm = []; Gtr = [];
        Tkc = []; Tko = []; Tdt = []; Ttm = []; Ttr = [];
        
        % Initialize conatiner arrays for the 20 kinetic properties for 
        % duplicate-eliminated, filtered cells.
        akc = []; ako = []; adt = []; atm = []; atr = [];
        ckc = []; cko = []; cdt = []; ctm = []; ctr = [];
        gkc = []; gko = []; gdt = []; gtm = []; gtr = [];
        tkc = []; tko = []; tdt = []; ttm = []; ttr = [];    

        % Iterate through all 96 barcodes.
        for bar = 1:length(bar_seqs) 

            % Iterate through all experiments and plot desired field. 
            pb = merge_list(bar).experiment(exp).s;

            % Find filtered pores.
            i_1 = extractfield(pb, 'alignment_length') >= x_min;
            pb_f1 = pb(i_1);
            i_2 = extractfield(pb_f1, 'iteration') <= x_max;
            pb_f2 = pb_f1(i_2);
            i_3 = extractfield(pb_f2, 'cons_identity') >= y_min;   
            pb_f3 = pb_f2(i_3);
            
            % Only look at structures with elements (can be empty).
            if length(pb_f3) > 1
            
                % Find 'coi' values.
                norm = extractfield(pb_f3, 'cons_identity')./100;
                cell_id = extractfield(pb_f3, 'cell_id');
                
                % Find the 20 kinetic parameters.
                aa = extractfield(pb_f3, 'level_call_A_k_cat_rate');
                bb = extractfield(pb_f3, 'level_call_A_k_off_rate'); 
                cc = extractfield(pb_f3, 'level_call_A_mean_dwell_time'); 
                dd = extractfield(pb_f3, 'level_call_A_ttt_median'); 
                ee = extractfield(pb_f3, 'level_call_A_ttt_rate');
                
                ff = extractfield(pb_f3, 'level_call_C_k_cat_rate'); 
                gg = extractfield(pb_f3, 'level_call_C_k_off_rate'); 
                hh = extractfield(pb_f3, 'level_call_C_mean_dwell_time'); 
                ii = extractfield(pb_f3, 'level_call_C_ttt_median'); 
                jj = extractfield(pb_f3, 'level_call_C_ttt_rate');
                
                kk = extractfield(pb_f3, 'level_call_G_k_cat_rate'); 
                ll = extractfield(pb_f3, 'level_call_G_k_off_rate'); 
                mm = extractfield(pb_f3, 'level_call_G_mean_dwell_time'); 
                nn = extractfield(pb_f3, 'level_call_G_ttt_median'); 
                oo = extractfield(pb_f3, 'level_call_G_ttt_rate');
                
                pp = extractfield(pb_f3, 'level_call_T_k_cat_rate'); 
                qq = extractfield(pb_f3, 'level_call_T_k_off_rate'); 
                rr = extractfield(pb_f3, 'level_call_T_mean_dwell_time'); 
                ss = extractfield(pb_f3, 'level_call_T_ttt_median'); 
                tt = extractfield(pb_f3, 'level_call_T_ttt_rate');

                % Generate container arrays for consensus identity, cell 
                % id and barcode id.
                CI = [CI; norm']; 
                GE = [GE; cell_id'];                 

                for b = 1:length(norm)
                    BC = [BC; bar'];
                end    
                
                for x = 1:length(norm)
                    EX = [EX; exp'];
                end    
                
                % Same for the 20 kinetic parameters.
                Akc = [Akc; aa']; Ako = [Ako; bb']; Adt = [Adt; cc']; Atm = [Atm; dd']; Atr = [Atr; ee'];
                Ckc = [Ckc; ff']; Cko = [Cko; gg']; Cdt = [Cdt; hh']; Ctm = [Ctm; ii']; Ctr = [Ctr; jj'];
                Gkc = [Gkc; kk']; Gko = [Gko; ll']; Gdt = [Gdt; mm']; Gtm = [Gtm; nn']; Gtr = [Gtr; oo'];
                Tkc = [Tkc; pp']; Tko = [Tko; qq']; Tdt = [Tdt; rr']; Ttm = [Ttm; ss']; Ttr = [Ttr; tt'];
                                
            end
        end

        % Filter out unique barcodes if more then one identified for a
        % single pore.
        [unique_cell_id, ia, ic] = unique(GE);
        
        for i = 1:length(unique_cell_id)
            in = find(strcmp(GE, unique_cell_id{i}) == 1);
            
            [ci(i), I] = max(CI(in)); % maximum consensus identity (%)
            rg = GE(in); ge{i} = rg{1}; % corresponding cell ID
            rb = BC(in); bc(i) = rb(I); % corresponding barcode ID
            re = EX(in); ex(i) = re(1); % corresponding experiment ID
            
            % 20 kinetic properties.
            rakc = Akc(in); akc(i) = rakc(I); % corresponding 'level_call_A_k_cat_rate'
            rako = Ako(in); ako(i) = rako(I); % corresponding 'level_call_A_k_off_rate'
            radt = Adt(in); adt(i) = radt(I); % corresponding 'level_call_A_mean_dwell_time'
            ratm = Atm(in); atm(i) = ratm(I); % corresponding 'level_call_A_ttt_median'
            ratr = Atr(in); atr(i) = ratr(I); % corresponding 'level_call_A_ttt_rate'
            
            rckc = Ckc(in); ckc(i) = rckc(I); % corresponding 'level_call_C_k_cat_rate'
            rcko = Cko(in); cko(i) = rcko(I); % corresponding 'level_call_C_k_off_rate'
            rcdt = Cdt(in); cdt(i) = rcdt(I); % corresponding 'level_call_C_mean_dwell_time'
            rctm = Ctm(in); ctm(i) = rctm(I); % corresponding 'level_call_C_ttt_median'
            rctr = Ctr(in); ctr(i) = rctr(I); % corresponding 'level_call_C_ttt_rate'
            
            rgkc = Gkc(in); gkc(i) = rgkc(I); % corresponding 'level_call_G_k_cat_rate'
            rgko = Gko(in); gko(i) = rgko(I); % corresponding 'level_call_G_k_off_rate'
            rgdt = Gdt(in); gdt(i) = rgdt(I); % corresponding 'level_call_G_mean_dwell_time'
            rgtm = Gtm(in); gtm(i) = rgtm(I); % corresponding 'level_call_G_ttt_median'
            rgtr = Gtr(in); gtr(i) = rgtr(I); % corresponding 'level_call_G_ttt_rate'
            
            rtkc = Tkc(in); tkc(i) = rtkc(I); % corresponding 'level_call_T_k_cat_rate'
            rtko = Tko(in); tko(i) = rtko(I); % corresponding 'level_call_T_k_off_rate'
            rtdt = Tdt(in); tdt(i) = rtdt(I); % corresponding 'level_call_T_mean_dwell_time'
            rttm = Ttm(in); ttm(i) = rttm(I); % corresponding 'level_call_T_ttt_median'
            rttr = Ttr(in); ttr(i) = rttr(I); % corresponding 'level_call_T_ttt_rate'

        end
        
        % Update container arrays.
        UC = UC + length(unique_cell_id);
        ALL_CI = [ALL_CI; ci']; ALL_GE = [ALL_GE; ge']; ALL_BC = [ALL_BC; bc']; ALL_EX = [ALL_EX; ex']; 
        
        AKC = [AKC; akc']; AKO = [AKO; ako']; ADT = [ADT; adt']; ATM = [ATM; atm']; ATR = [ATR; atr'];
        CKC = [CKC; ckc']; CKO = [CKO; cko']; CDT = [CDT; cdt']; CTM = [CTM; ctm']; CTR = [CTR; ctr'];        
        GKC = [GKC; gkc']; GKO = [GKO; gko']; GDT = [GDT; gdt']; GTM = [GTM; gtm']; GTR = [GTR; gtr'];       
        TKC = [TKC; tkc']; TKO = [TKO; tko']; TDT = [TDT; tdt']; TTM = [TTM; ttm']; TTR = [TTR; ttr'];
        
    end
    
    % Replace non-numeric elements (NaN) with 0 in all matrixes.
    ALL_CI(isnan(ALL_CI)) = 0; ALL_BC(isnan(ALL_BC)) = 0; ALL_EX(isnan(ALL_EX)) = 0;
    
    AKC(isnan(AKC)) = 0; AKO(isnan(AKO)) = 0; ADT(isnan(ADT)) = 0; ATM(isnan(ATM)) = 0; ATR(isnan(ATR)) = 0;
    CKC(isnan(CKC)) = 0; CKO(isnan(CKO)) = 0; CDT(isnan(CDT)) = 0; CTM(isnan(CTM)) = 0; CTR(isnan(CTR)) = 0;
    GKC(isnan(GKC)) = 0; GKO(isnan(GKO)) = 0; GDT(isnan(GDT)) = 0; GTM(isnan(GTM)) = 0; GTR(isnan(GTR)) = 0;
    TKC(isnan(TKC)) = 0; TKO(isnan(TKO)) = 0; TDT(isnan(TDT)) = 0; TTM(isnan(TTM)) = 0; TTR(isnan(TTR)) = 0;
            
    ALL_GE
    ALL_BC
    ALL_EX
    
    % Create filtered data matrix.
    DATA = horzcat(ALL_BC, ALL_EX, ALL_CI, ...        
                   AKC, AKO, ADT, ATM, ATR, ...
                   CKC, CKO, CDT, CTM, CTR, ...        
                   GKC, GKO, GDT, GTM, GTR, ...       
                   TKC, TKO, TDT, TTM, TTR);
                
    % Write filtered data to a matrix and save it.           
    dlmwrite('data_matrix.txt', DATA, 'delimiter', '\t', 'precision', '%.4f');
        
    % Analysis type 0 - all barcodes considered in PCA analysis.
    if type == 0 
        
        % Retrieve the matrix of 20 kinetic properties only.
        BAR = DATA(:, 4:end);   
        
    % Analysis type 1 - barcodes 1-32 considered in PCA analysis.
    elseif type == 1
   
        % All barcodes in set 1.
        i1 = DATA(:,1)<33;
        BAR = DATA(i1, 4:end);
        
    % Analysis type 2 - barcodes 33-64 considered in PCA analysis.
    elseif type == 2

        % All barcodes in set 2.
        ii = DATA(:,1)>33;
        DATA2 = DATA(ii,:);
        i2 = DATA2(:,1)<65;
        BAR = DATA2(i2, 4:end);
        
    % Analysis type 3 - barcodes 65-96 considered in PCA analysis.
    elseif type == 3

        % All barcodes in set 3.
        i3 = DATA(:,1)>64;
        BAR = DATA(i3, 4:end);
        
    else
            
        % Pick a specific barcode (maximum occurence, for example).
        ie = DATA(:,1)== type;
        BAR = DATA(ie, 4:end);
        
    end
    
    % Calculate principle components of data matrix.
    opt = statset('pca'); opt.MaxIter = 1e+6;
    [coeff, score, latent, tsquared, explained, mu] = pca(BAR, 'Algorithm', 'svd', 'Options', opt);
    P = BAR*coeff;
    PC1 = P(:,1); PC2 = P(:,2);

    % Create 2D plot of PC1 vs. PC2.
    scatter(PC1, PC2, 'o', 'LineWidth', 1);
    grid;
    title('Filtered PCA to Map Back');
    xlabel('PC1');
    ylabel('PC2');
    axis([-4 8 -4 10]);
    hold on;
    
    BAR
    size(BAR)
    explained 
    
    disp(['--> PROCESSED DATA SET: ' list(e).name]); 
    
 end         

% Save plot.
savefig([num2str(type), '_pca_mapback_pol_filter.fig']);
print('-dbmp', [num2str(type), '_pca_mapback_pol_filter.bmp']);

% Move all figures to 'plots' directory.
movefile('*.fig', cdir);
movefile('*.bmp', cdir);

% Close all open figures.
close all;   

% Navigate to working directory.
cd(work_dir);

fprintf('\n');
disp('--> PCA map back end');
fprintf('\n');

% End timer.
toc